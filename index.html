<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Bulletin Template/title>
    <style>
        /* CSS Variables for Font Customization */
        :root {
            --site-font: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            --monospace-font: Consolas, 'Fira Code', monospace;
        }

        /* --- Global Styles --- */
        body {
            font-family: var(--site-font); 
            padding: 20px;
            background-color: #2c2c2c;
            color: #e0e0e0;
        }
        .container {
            width: 90%; 
            max-width: 1000px;
            margin: 0 auto;
            background: #3c3c3c;
            padding: 25px;
            border-radius: 10px;
            box-shadow: 0 6px 15px rgba(0,0,0,0.3);
        }
        h1 {
            color: #bb86fc;
            text-align: center;
            border-bottom: 2px solid #505050;
            padding-bottom: 10px;
            margin-bottom: 20px;
        }
        .section-header {
            color: #90caf9;
            font-size: 1.2em;
            margin: 20px 0 10px;
            padding-left: 10px;
            border-left: 5px solid #90caf9;
            font-weight: 600; 
        }
        p {
            color: #b0b0b0;
        }

        /* --- Input and Textarea Base Styles --- */
        #template-input, #output-textarea, 
        .field-card textarea, /* Target new textarea fields */
        .field-card input[type="number"], 
        .field-card select, 
        #custom-font-url, #custom-font-name {
            /* General input/textarea styles */
            width: 100%; 
            padding: 12px;
            margin-bottom: 15px;
            border: 1px solid #626262;
            border-radius: 6px;
            box-sizing: border-box; /* Crucial for sizing control */
            font-size: 1em;
            background-color: #4a4a4a;
            color: #e0e0e0;
            min-height: 40px;
            font-family: var(--site-font);
        }
        
        /* >>> CRITICAL FIX: Make ALL editable text boxes fully resizable <<< */
        #template-input, 
        #output-textarea, 
        #custom-font-url,
        #custom-font-name,
        /* Applying resize property to the new resizable-textarea class */
        .resizable-textarea { 
            resize: both !important; 
            overflow: auto !important; 
            max-width: 100%;
            /* Explicitly setting width to 100% and letting resize override it */
            width: 100%; 
            min-height: 40px; 
            box-sizing: border-box; /* Ensure borders don't break resizing */
            min-width: 100px; /* Added base width to ensure horizontal handle appears */
        }
        
        /* Target number inputs (if they exist) to remove resizing */
        .field-card input[type="number"] {
            resize: none !important;
        }
        
        #template-input {
            min-height: 120px;
        }
        
        #output-textarea {
            min-height: 180px;
            background-color: #212121;
            font-family: var(--site-font); 
            white-space: pre-wrap;
            border: 2px solid #6d6d6d;
        }

        /* Disable resizing on elements that shouldn't be resized */
        .field-card select, 
        .input-group input[type="checkbox"],
        #font-selector {
            resize: none !important;
        }


        /* --- Field Settings Area (Layout Styles) --- */
        #field-settings {
            display: flex;
            flex-direction: column;
            gap: 15px;
            padding: 10px 0;
        }
        .field-card {
            padding: 15px;
            border: 1px solid #64b5f6;
            border-radius: 6px;
            background-color: #424242;
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            align-items: flex-start;
        }
        .field-card > label {
            font-weight: 600;
            color: #a7d9ff;
            flex-basis: 100%;
            margin-bottom: 5px;
        }
        
        /* Styles for the new Field Name and Input Value groups */
        .field-name-group, .input-value-group {
            display: flex;
            flex-direction: column;
            flex-basis: 100%; 
            
            /* CRITICAL FLEX FIX: min-width: 0 allows the textarea child to fully control its width and resize */
            min-width: 0; 
            overflow: visible; /* Ensures the resize handle isn't clipped */
            flex-grow: 1; /* Allow them to grow equally */
        }
        
        @media (min-width: 600px) {
            .field-name-group, .input-value-group {
                /* Made width a bit looser to prevent restriction */
                flex-basis: calc(50% - 5px); 
            }
        }
        
        .field-label {
            display: block;
            font-size: 0.8em;
            color: #b0b0b0;
            margin-bottom: 3px;
            width: 100%;
        }

        /* Other controls group */
        .input-group {
            display: flex;
            flex-direction: column;
            min-width: 150px;
            flex-grow: 1;
            min-width: auto; 
            max-width: none;
        }
        .input-group span {
            font-size: 0.8em;
            color: #b0b0b0;
            margin-bottom: 3px;
        }
        
        .converter-display {
            padding: 5px 10px;
            background-color: #6200ee;
            color: white;
            border-radius: 4px;
            font-weight: bold;
            text-align: center;
            min-width: 80px;
            align-self: flex-end; /* Align the converted output to the bottom */
            margin-bottom: 15px;
        }

        .input-group input[type="checkbox"] {
            width: auto;
            margin-top: 5px;
            margin-bottom: 0;
            padding: 0;
            border: 1px solid #90caf9;
            background-color: #4a4a4a;
        }
        
        /* --- Utility Styles --- */
        #copy-button {
            padding: 10px 20px;
            background-color: #03dac6;
            color: #121212;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-weight: bold;
            margin-top: 10px;
            transition: background-color 0.2s;
        }
        #copy-button:hover {
            background-color: #03a89a;
        }

        .font-controls {
            display: flex;
            gap: 10px;
            align-items: center;
            flex-wrap: wrap;
            margin-bottom: 20px;
        }
        #font-selector {
            padding: 8px;
            border: 1px solid #626262;
            border-radius: 4px;
            background-color: #4a4a4a;
            color: #e0e0e0;
            font-family: var(--site-font);
        }
        .font-input-group {
            display: flex;
            flex-direction: column;
            min-width: 150px;
            flex-grow: 1;
        }
    </style>
</head>
<body>

    <div class="container">
        <h1>Bulletin Template Generator</h1>
        
        <div class="font-controls">
            <div class="font-input-group">
                <label for="font-selector" style="font-weight: bold;">Select Font:</label>
                <select id="font-selector" onchange="changeFont(this.value)">
                    <option value="'Segoe UI', Tahoma, Geneva, Verdana, sans-serif">Segoe UI (Default)</option>
                    <option value="Arial, sans-serif">Arial</option>
                    <option value="'Times New Roman', serif">Times New Roman</option>
                    <option value="'Courier New', monospace">Courier New</option>
                    <option value="'Roboto Mono', monospace">Roboto Mono (Monospace)</option>
                    <option value="'Open Sans', sans-serif">Open Sans</option>
                    <option value="Verdana, sans-serif">Verdana</option>
                    <option value="CustomFontFamily">Custom (See Below)</option>
                </select>
            </div>
            
            <div class="font-input-group">
                <label for="custom-font-url" style="font-weight: bold;">Custom Font URL (e.g., Google Fonts @import)</label>
                <textarea id="custom-font-url" placeholder="e.g., https://fonts.googleapis.com/css2?family=..." oninput="saveCustomFontSettings()" class="resizable-textarea"></textarea>
            </div>
            
            <div class="font-input-group">
                <label for="custom-font-name" style="font-weight: bold;">Custom Font Family Name</label>
                <textarea id="custom-font-name" placeholder="e.g., 'Roboto Mono'" oninput="saveCustomFontSettings()" class="resizable-textarea"></textarea>
            </div>
        </div>

        <div class="section-header">1. Define Your Template (Use **\_\_** for editable fields)</div>
        <textarea id="template-input" placeholder="Tropical Storm Andaya Advisory #__&#10;Strength: __ knots (Convert to kph) kph&#10;Pressure: __ hPa&#10;Direction: __"></textarea>
        
        <div class="section-header">2. Field Settings and Inputs</div>
        <p style="font-size: 0.9em;">
            Configure field names, input values, and set up conversions. All editable text areas are now fully resizable.
        </p>
        <div id="field-settings">
            </div>

        <div class="section-header">3. Generated Text</div>
        <textarea id="output-textarea" readonly></textarea>
        <button id="copy-button" onclick="copyOutput()">ðŸ“‹ Copy Generated Text</button>

    </div>

    <script>
        const TEMPLATE_DELIMITER = '__';
        const STORAGE_KEY = 'templateAppProgressV8'; 
        const FONT_STORAGE_KEY = 'templateAppFontV7';
        const CUSTOM_FONT_STORAGE_KEY = 'templateAppCustomFontV7';
        
        const DEFAULT_TEMPLATE = 'Tropical Storm Andaya Advisory #__\nStrength: __ knots (Convert to kph) kph\nPressure: __ hPa\nDirection: __';

        const CONVERSION_FACTORS = {
            'mph': 1.0,
            'kph': 1.60934,
            'knots': 0.868976,
        };

        const templateInput = document.getElementById('template-input');
        const fieldSettingsDiv = document.getElementById('field-settings');
        const outputTextarea = document.getElementById('output-textarea');
        const fontSelector = document.getElementById('font-selector');
        const customFontUrlInput = document.getElementById('custom-font-url');
        const customFontNameInput = document.getElementById('custom-font-name');

        let fields = [];
        let lastActiveElementId = null;

        // --- CUSTOMIZATION & UTILITIES ---

        // Function to change the site font (applies site-wide)
        function changeFont(fontValue) {
            const finalFont = fontValue === 'CustomFontFamily' && customFontNameInput.value 
                ? customFontNameInput.value 
                : fontValue;
                
            // Set the CSS variable used by all elements
            document.documentElement.style.setProperty('--site-font', finalFont);
            localStorage.setItem(FONT_STORAGE_KEY, fontValue);
        }
        
        // Load custom font dynamically
        function loadCustomFont(url) {
            let oldLink = document.getElementById('custom-font-link');
            let oldStyle = document.getElementById('custom-font-style');
            if (oldLink) oldLink.remove();
            if (oldStyle) oldStyle.remove();

            if (url) {
                if (url.startsWith('http')) {
                    let link = document.createElement('link');
                    link.id = 'custom-font-link';
                    link.rel = 'stylesheet';
                    link.href = url;
                    document.head.appendChild(link);
                } else if (url.startsWith('@import')) {
                    let style = document.createElement('style');
                    style.id = 'custom-font-style';
                    style.textContent = url;
                    document.head.appendChild(style);
                }
            }
        }
        
        // Save and apply custom font settings
        function saveCustomFontSettings() {
            const customSettings = {
                url: customFontUrlInput.value,
                name: customFontNameInput.value
            };
            localStorage.setItem(CUSTOM_FONT_STORAGE_KEY, JSON.stringify(customSettings));
            loadCustomFont(customSettings.url);
            
            if (fontSelector.value === 'CustomFontFamily') {
                changeFont('CustomFontFamily');
            }
            saveState();
        }

        // Function to handle the Copy button click
        function copyOutput() {
            outputTextarea.select();
            document.execCommand('copy');
            const originalText = document.getElementById('copy-button').textContent;
            document.getElementById('copy-button').textContent = 'âœ… Copied!';
            setTimeout(() => {
                document.getElementById('copy-button').textContent = originalText;
            }, 1500);
        }

        // --- PERSISTENCE (Save/Load) ---

        // Save state to Local Storage
        function saveState() {
            const state = {
                template: templateInput.value,
                fields: fields,
                lastActiveElementId: lastActiveElementId 
            };
            localStorage.setItem(STORAGE_KEY, JSON.stringify(state));
        }

        // Load state from Local Storage
        function loadState() {
            // Load Custom Font Settings
            const savedCustomFont = localStorage.getItem(CUSTOM_FONT_STORAGE_KEY);
            if (savedCustomFont) {
                const customSettings = JSON.parse(savedCustomFont);
                customFontUrlInput.value = customSettings.url || '';
                customFontNameInput.value = customSettings.name || '';
                loadCustomFont(customSettings.url);
            }
            
            // Load Font Selector Value
            const savedFont = localStorage.getItem(FONT_STORAGE_KEY);
            if (savedFont) {
                fontSelector.value = savedFont; 
                changeFont(savedFont);
            } else {
                changeFont(fontSelector.value);
            }
            
            // Load Template/Fields
            const savedState = localStorage.getItem(STORAGE_KEY);
            if (savedState) {
                const state = JSON.parse(savedState);
                templateInput.value = state.template || '';
                fields = state.fields || [];
                lastActiveElementId = state.lastActiveElementId || null;
            } else {
                 // ONLY set default template if no state is found
                templateInput.value = DEFAULT_TEMPLATE;
            }
            
            generateFieldCards(); 
            window.addEventListener('load', restoreFocus);
        }
        
        // --- FOCUS RETENTION ---

        document.addEventListener('focusin', (event) => {
            if (event.target.tagName === 'INPUT' || event.target.tagName === 'TEXTAREA' || event.target.tagName === 'SELECT') {
                lastActiveElementId = event.target.id;
                saveState();
            }
        });

        function restoreFocus() {
             if (lastActiveElementId) {
                const lastActiveElement = document.getElementById(lastActiveElementId);
                if (lastActiveElement && document.activeElement !== lastActiveElement) {
                    lastActiveElement.focus();
                    if (lastActiveElement.setSelectionRange) {
                        const len = lastActiveElement.value.length;
                        lastActiveElement.setSelectionRange(len, len);
                    }
                }
            }
        }
        window.addEventListener('focus', restoreFocus);


        // --- CORE LOGIC ---

        function convertSpeed(value, fromUnit, toUnit) {
            value = parseFloat(value);
            if (isNaN(value)) return 0; // Return 0, not value, if input is invalid
            
            fromUnit = fromUnit.toLowerCase();
            toUnit = toUnit.toLowerCase();

            if (!CONVERSION_FACTORS[fromUnit] || !CONVERSION_FACTORS[toUnit]) return value.toFixed(1); // Keep original if units are unknown

            let baseValue = value / CONVERSION_FACTORS[fromUnit];
            let convertedValue = baseValue * CONVERSION_FACTORS[toUnit];
            
            return convertedValue.toFixed(1);
        }

        function generateFieldCards() {
            const template = templateInput.value;
            // Use a regex to find all occurrences of the TEMPLATE_DELIMITER (e.g., __)
            const matches = [...template.matchAll(new RegExp(TEMPLATE_DELIMITER, 'g'))];
            const fieldCount = matches.length;
            
            let newFields = [];
            
            for (let i = 0; i < fieldCount; i++) {
                let existingField = fields[i];
                if (existingField) {
                    existingField.id = `field-${i}`;
                    newFields.push(existingField);
                } else {
                    newFields.push({
                        id: `field-${i}`,
                        name: `Field ${i + 1}`,
                        value: '',
                        isConverter: false,
                        fromUnit: 'knots',
                        toUnit: 'kph',
                        conversionText: '',
                    });
                }
            }

            fields = newFields;
            renderFieldSettings();
            updateOutput();
            saveState();
        }

        function renderFieldSettings() {
            let html = '';
            
            fields.forEach((field, index) => {
                const isConverterChecked = field.isConverter ? 'checked' : '';
                const conversionBlockStyle = field.isConverter ? 'style="display: flex; gap: 10px; align-items: flex-end; flex-wrap: wrap;"' : 'style="display: none;"';
                const placeholderText = field.name;
                
                // Get the current value for the name/value textareas
                const fieldNameValue = field.name || '';
                const fieldInputValue = field.value || '';

                html += `
                    <div class="field-card" data-index="${index}">
                        <label>Configuration for Placeholder ${index + 1}: ${fieldNameValue}</label>
                        
                        <div class="field-name-group">
                            <span class="field-label">Field Name</span>
                            <textarea id="${field.id}-name" 
                                oninput="updateFieldName(${index}, this.value)" placeholder="e.g., Advisory Number" class="resizable-textarea">${fieldNameValue}</textarea>
                        </div>

                        <div class="input-value-group">
                            <span class="field-label">Input Value</span>
                            ${field.isConverter 
                                ? `<input type="number" id="${field.id}-value" value="${fieldInputValue}" 
                                    oninput="updateFieldValue(${index}, this.value)" placeholder="${placeholderText}">`
                                : `<textarea id="${field.id}-value" 
                                    oninput="updateFieldValue(${index}, this.value)" placeholder="${placeholderText}" class="resizable-textarea">${fieldInputValue}</textarea>`
                            }
                        </div>
                        
                        <div class="input-group">
                            <span>Converter?</span>
                            <input type="checkbox" id="${field.id}-converter" ${isConverterChecked} 
                                onchange="toggleConverter(${index}, this.checked)">
                        </div>

                        <div id="${field.id}-conversion-block" ${conversionBlockStyle}>
                            <div class="input-group">
                                <span>Input Unit (e.g., knots)</span>
                                <select id="${field.id}-from-unit" onchange="updateConversionSettings(${index})">
                                    ${Object.keys(CONVERSION_FACTORS).map(unit => 
                                        `<option value="${unit}" ${field.fromUnit === unit ? 'selected' : ''}>${unit.toUpperCase()}</option>`
                                    ).join('')}
                                </select>
                            </div>

                            <div class="input-group">
                                <span>Target Unit (e.g., kph)</span>
                                <select id="${field.id}-to-unit" onchange="updateConversionSettings(${index})">
                                    ${Object.keys(CONVERSION_FACTORS).map(unit => 
                                        `<option value="${unit}" ${field.toUnit === unit ? 'selected' : ''}>${unit.toUpperCase()}</option>`
                                    ).join('')}
                                </select>
                            </div>
                            
                            <div class="input-group">
                                <span>Text to Replace (e.g., (Convert to kph))</span>
                                <textarea id="${field.id}-text" 
                                    oninput="updateConversionSettings(${index})" placeholder="Text to replace" class="resizable-textarea">${field.conversionText}</textarea>
                            </div>

                            <div class="converter-display" id="${field.id}-converted-output">
                                ${field.isConverter ? (convertSpeed(field.value, field.fromUnit, field.toUnit) + ' ' + field.toUnit.toUpperCase()) : ('0.0 ' + field.toUnit.toUpperCase())}
                            </div>
                        </div>
                    </div>
                `;
            });

            fieldSettingsDiv.innerHTML = html;
        }

        function updateFieldName(index, name) {
            fields[index].name = name;
            // Update placeholder for the corresponding value input/textarea
            const valueInput = document.getElementById(`${fields[index].id}-value`);
            if (valueInput) valueInput.placeholder = name;
            
            const card = document.querySelector(`.field-card[data-index="${index}"]`);
            if (card) {
                card.querySelector('label').textContent = `Configuration for Placeholder ${index + 1}: ${name}`;
            }
            saveState();
        }
        
        function updateFieldValue(index, value) {
            fields[index].value = value;
            updateOutput();
            saveState();
        }

        function toggleConverter(index, isChecked) {
            fields[index].isConverter = isChecked;
            renderFieldSettings(); 
            saveState();
        }

        function updateConversionSettings(index) {
            const field = fields[index];
            const card = document.querySelector(`.field-card[data-index="${index}"]`);
            
            if (card) {
                field.fromUnit = card.querySelector(`#${field.id}-from-unit`).value;
                field.toUnit = card.querySelector(`#${field.id}-to-unit`).value;
                field.conversionText = card.querySelector(`#${field.id}-text`).value;
            }
            updateOutput();
            saveState();
        }

        function updateOutput() {
            let template = templateInput.value;
            let finalOutput = template;

            // 1. Replace the actual placeholders (the __) with the field values
            let fieldIndex = 0;
            finalOutput = finalOutput.replace(new RegExp(TEMPLATE_DELIMITER, 'g'), () => {
                const value = fields[fieldIndex]?.value || '';
                fieldIndex++;
                // If value is empty, replace it with an empty string, NOT the placeholder itself
                return value; 
            });

            // 2. Perform conversion and text replacement for converter fields
            fields.forEach(field => {
                if (field.isConverter) {
                    // Convert speed, defaulting to 0 if input value is empty or invalid
                    const valueToConvert = field.value || '0'; 
                    const convertedValue = convertSpeed(valueToConvert, field.fromUnit, field.toUnit);

                    // Update the display for the converted value
                    const converterDisplay = document.getElementById(`${field.id}-converted-output`);
                    if (converterDisplay) {
                        converterDisplay.textContent = `${convertedValue} ${field.toUnit.toUpperCase()}`;
                    }

                    // Replace the conversion text (e.g., "(Convert to kph)") in the final output
                    // IMPORTANT: We use the value from the *template* before the first replace, but we 
                    // must replace it in the *finalOutput* after the first replacement pass.
                    if (field.conversionText) {
                        // Use a global replace to catch all instances if somehow duplicated
                        // Escape any special regex characters in the conversionText
                        const escapedText = field.conversionText.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
                        finalOutput = finalOutput.replace(new RegExp(escapedText, 'g'), convertedValue);
                    }
                }
            });

            outputTextarea.value = finalOutput;
        }

        // --- INITIALIZATION ---
        templateInput.addEventListener('input', generateFieldCards);
        window.addEventListener('load', loadState);
    </script>

</body>
</html>
